[
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "main",
        "input": "Scrivi una funzione cpp chiamata 'main' con argomenti: ()",
        "output": "main() {\n#ifdef _DEBUG\n\tprintf( \"debug\\n\" );\n#endif\n\tfor ( int i = 1; i < 10; i++ ) {\n\t\tfor ( int j = 1; j < 10; j++ ) {\n\t\t\tprintf( \"%dx%d=%d\\n\", i, j, i * j );\n\t\t}\n\t}\n\treturn 0;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "solve_impl",
        "input": "Scrivi una funzione cpp chiamata 'solve_impl' con argomenti: (const index_tuple<Indices...>&)",
        "output": "solve_impl(const index_tuple<Indices...>&) {\n    return std::array<int, 9>{{printf(\"%ldx%ld=%ld\\n\", (N + 1), (Indices + 1), ((N + 1) * (Indices + 1)))...}};\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "solve",
        "input": "Scrivi una funzione cpp chiamata 'solve' con argomenti: (const index_tuple<Indices...>& t)",
        "output": "solve(const index_tuple<Indices...>& t) {\n    return std::array<std::array<int, 9>, 9>{{solve_impl<Indices>(t)...}};\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "L",
        "input": "Scrivi una funzione cpp chiamata 'L' con argomenti: (const P &a, const P &b)",
        "output": "L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "a",
        "input": "Scrivi una funzione cpp chiamata 'a' con argomenti: (const P& a, const P& b)",
        "output": "a(const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "main",
        "input": "Scrivi una funzione cpp chiamata 'main' con argomenti: ()",
        "output": "main() {\n#ifdef _DEBUG\n\tprintf( \"Debug Mode\\n\" );\n#endif\n\tfor ( int i = 1; i < 10; i++ ) {\n\t\tfor ( int j = 1; j < 10; j++ ) {\n\t\t\tdump( i );\n\t\t\tdump( j );\n\t\t\tprintf( \"%dx%d=%d\\n\", i, j, i * j );\n\t\t}\n\t}\n\treturn 0;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "convert",
        "input": "Scrivi una funzione cpp chiamata 'convert' con argomenti: (const F &f, T &t)",
        "output": "convert(const F &f, T &t) {\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "main",
        "input": "Scrivi una funzione cpp chiamata 'main' con argomenti: ()",
        "output": "main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n      cout<<fixed<<setprecision(20);\n    mainmain();\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "main",
        "input": "Scrivi una funzione cpp chiamata 'main' con argomenti: ()",
        "output": "main() {\n#ifdef _DEBUG\n\tprintf( \"debug\\n\" );\n#endif\n\tfor ( int i = 1; i < 10; i++ ) {\n\t\tfor ( int j = 1; j < 10; j++ ) {\n\t\t\tprintf( \"%dx%d=%d\\n\", i, j, i * j);\n\t\t}\n\t}\n\treturn 0;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "input",
        "input": "Scrivi una funzione cpp chiamata 'input' con argomenti: ()",
        "output": "input() {\n\t\n\n\treturn;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "main",
        "input": "Scrivi una funzione cpp chiamata 'main' con argomenti: ()",
        "output": "main() {\n\tfor ( int i = 1; i < 10; i++ ) {\n\t\tfor ( int j = 1; j < 10; j++ ) {\n\t\t\t//\n\t\t\tprintf( \"%dx%d=%d\\n\", i, j, i * j );\n\t\t}\n\t}\n\treturn 0;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "cheak",
        "input": "Scrivi una funzione cpp chiamata 'cheak' con argomenti: (int x, int y, int xMax, int yMax)",
        "output": "cheak(int x, int y, int xMax, int yMax) {\n\treturn x >= 0 && y >= 0 && xMax > x && yMax > y;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "pin",
        "input": "Scrivi una funzione cpp chiamata 'pin' con argomenti: ()",
        "output": "pin() {\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "dot",
        "input": "Scrivi una funzione cpp chiamata 'dot' con argomenti: (P a,P b)",
        "output": "dot(P a,P b) {\n\treturn real(conj(a)*b);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "cross",
        "input": "Scrivi una funzione cpp chiamata 'cross' con argomenti: (P a,P b)",
        "output": "cross(P a,P b) {\n\treturn imag(conj(a)*b);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "ccw",
        "input": "Scrivi una funzione cpp chiamata 'ccw' con argomenti: (P a, P b, P c)",
        "output": "ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "projection",
        "input": "Scrivi una funzione cpp chiamata 'projection' con argomenti: (L a,P p)",
        "output": "projection(L a,P p) {\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "reflection",
        "input": "Scrivi una funzione cpp chiamata 'reflection' con argomenti: (L a,P p)",
        "output": "reflection(L a,P p) {\n\treturn p+2.0*(projection(a,p)-p);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "intersectLL",
        "input": "Scrivi una funzione cpp chiamata 'intersectLL' con argomenti: (const L &l, const L &m)",
        "output": "intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "intersectLS",
        "input": "Scrivi una funzione cpp chiamata 'intersectLS' con argomenti: (const L &l, const L &s)",
        "output": "intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "intersectLP",
        "input": "Scrivi una funzione cpp chiamata 'intersectLP' con argomenti: (const L &l, const P &p)",
        "output": "intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "intersectSS",
        "input": "Scrivi una funzione cpp chiamata 'intersectSS' con argomenti: (const L &s, const L &t)",
        "output": "intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "intersectSP",
        "input": "Scrivi una funzione cpp chiamata 'intersectSP' con argomenti: (const L &s, const P &p)",
        "output": "intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "intersect_ls",
        "input": "Scrivi una funzione cpp chiamata 'intersect_ls' con argomenti: (L a,L b)",
        "output": "intersect_ls(L a,L b) {\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "distanceLP",
        "input": "Scrivi una funzione cpp chiamata 'distanceLP' con argomenti: (const L &l, const P &p)",
        "output": "distanceLP(const L &l, const P &p) {\n    if(dot(l[1]-l[0],p-l[0]) < EPS) return abs(p-l[0]);\n    if(dot(l[0]-l[1],p-l[1]) < EPS) return abs(p-l[1]);\n\treturn abs(p - projection(l, p));\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "distanceLL",
        "input": "Scrivi una funzione cpp chiamata 'distanceLL' con argomenti: (const L &l, const L &m)",
        "output": "distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "distanceLS",
        "input": "Scrivi una funzione cpp chiamata 'distanceLS' con argomenti: (const L &l, const L &s)",
        "output": "distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "distanceSP",
        "input": "Scrivi una funzione cpp chiamata 'distanceSP' con argomenti: (const L &s, const P &p)",
        "output": "distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "distanceSS",
        "input": "Scrivi una funzione cpp chiamata 'distanceSS' con argomenti: (const L &s, const L &t)",
        "output": "distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "intersectCL",
        "input": "Scrivi una funzione cpp chiamata 'intersectCL' con argomenti: (C c,const L &l)",
        "output": "intersectCL(C c,const L &l) {\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.c < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "crosspointCL",
        "input": "Scrivi una funzione cpp chiamata 'crosspointCL' con argomenti: (C c,L l)",
        "output": "crosspointCL(C c,L l) {\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "crosspointCC",
        "input": "Scrivi una funzione cpp chiamata 'crosspointCC' con argomenti: (C a,C b)",
        "output": "crosspointCC(C a,C b) {\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "crosspointLL",
        "input": "Scrivi una funzione cpp chiamata 'crosspointLL' con argomenti: (const L &l, const L &m)",
        "output": "crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "area",
        "input": "Scrivi una funzione cpp chiamata 'area' con argomenti: (const G &g)",
        "output": "area(const G &g) {\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "inconvex",
        "input": "Scrivi una funzione cpp chiamata 'inconvex' con argomenti: (const G& g, const P& p)",
        "output": "inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "rep",
        "input": "Scrivi una funzione cpp chiamata 'rep' con argomenti: (i,n)",
        "output": "rep(i,n) {\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "convex_hull",
        "input": "Scrivi una funzione cpp chiamata 'convex_hull' con argomenti: (G &ps)",
        "output": "convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "convex_diameter",
        "input": "Scrivi una funzione cpp chiamata 'convex_diameter' con argomenti: (const G &pt)",
        "output": "convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "convex_cut",
        "input": "Scrivi una funzione cpp chiamata 'convex_cut' con argomenti: (const G& g, const L& l)",
        "output": "convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "turn",
        "input": "Scrivi una funzione cpp chiamata 'turn' con argomenti: (P p,double t)",
        "output": "turn(P p,double t) {\n\treturn p*exp(P(.0,t*PI/180.0));\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "sq",
        "input": "Scrivi una funzione cpp chiamata 'sq' con argomenti: (T x)",
        "output": "sq(T x) {\n\treturn x * x;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "chmax",
        "input": "Scrivi una funzione cpp chiamata 'chmax' con argomenti: (T &x, U y)",
        "output": "chmax(T &x, U y) {\n\tif (x >= y) return false;\n\tx = y;\n\treturn true;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "chmin",
        "input": "Scrivi una funzione cpp chiamata 'chmin' con argomenti: (T &x, U y)",
        "output": "chmin(T &x, U y) {\n\tif (x <= y) return false;\n\tx = y;\n\treturn true;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "sort",
        "input": "Scrivi una funzione cpp chiamata 'sort' con argomenti: (T &c)",
        "output": "sort(T &c) {\n\tsort(all(c));\n\treturn c;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "reverse",
        "input": "Scrivi una funzione cpp chiamata 'reverse' con argomenti: (T &c)",
        "output": "reverse(T &c) {\n\treverse(all(c));\n\treturn c;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "unique",
        "input": "Scrivi una funzione cpp chiamata 'unique' con argomenti: (T &c)",
        "output": "unique(T &c) {\n\tsort(all(c));\n\tc.erase(unique(all(c)), end(c));\n\treturn c;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "sorted",
        "input": "Scrivi una funzione cpp chiamata 'sorted' con argomenti: (const T &c)",
        "output": "sorted(const T &c) {\n\tT d = c;\n\treturn move(sort(d));\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "reversed",
        "input": "Scrivi una funzione cpp chiamata 'reversed' con argomenti: (const T &c)",
        "output": "reversed(const T &c) {\n\tT d = c;\n\treturn move(reverse(d));\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "uniqued",
        "input": "Scrivi una funzione cpp chiamata 'uniqued' con argomenti: (const T &c)",
        "output": "uniqued(const T &c) {\n\tT d = c;\n\treturn move(unique(d));\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "modpow",
        "input": "Scrivi una funzione cpp chiamata 'modpow' con argomenti: (ll x, ll e, ll mod = 1000000007)",
        "output": "modpow(ll x, ll e, ll mod = 1000000007) {\n\tll res = 1;\n\te %= mod - 1;\n\twhile (e){\n\t\tif (e & 1) res = res * x;\n\t\tx = x * x;\n\t\te >>= 1;\n\t}\n\treturn res;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "in",
        "input": "Scrivi una funzione cpp chiamata 'in' con argomenti: ()",
        "output": "in() {\n\tll x;\n\tscanf(\"%lld\", &x);\n\treturn x;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "inD",
        "input": "Scrivi una funzione cpp chiamata 'inD' con argomenti: ()",
        "output": "inD() {\n\tdouble x;\n\tscanf(\"%lf\", &x);\n\treturn x;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "inS",
        "input": "Scrivi una funzione cpp chiamata 'inS' con argomenti: ()",
        "output": "inS() {\n\tstatic char s[1 << 20];\n\tscanf(\"%s\", s);\n\treturn s;\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "rot45",
        "input": "Scrivi una funzione cpp chiamata 'rot45' con argomenti: (ll x, ll y)",
        "output": "rot45(ll x, ll y) {\n\treturn mp(x + y, x - y);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "rot45inv",
        "input": "Scrivi una funzione cpp chiamata 'rot45inv' con argomenti: (ll u, ll v)",
        "output": "rot45inv(ll u, ll v) {\n\treturn mp((u + v) / 2, (u - v) / 2);\n}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "t",
        "input": "Scrivi una funzione cpp chiamata 't' con argomenti: (const T &t, ostream &os)",
        "output": "t(const T &t, ostream &os) {\n\t\tprint_tuple<T, N - 1>::print(t, os);\n\t\tos << \" \" << get<N - 1>(t);\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "ModInt",
        "input": "Scrivi una funzione cpp chiamata 'ModInt' con argomenti: (const std::string &s)",
        "output": "ModInt(const std::string &s) {\n\t\tbool neg = false;\n\t\tauto it = begin(s);\n\t\tif (*it == '-'){\n\t\t\tneg = true;\n\t\t\t++it;\n\t\t}\n\t\tv = 0;\n\t\twhile (it != end(s)){\n\t\t\tv = (v * 10 + (*it++ - '0')) % MOD;\n\t\t}\n\t\tif (neg && v) v = MOD - v;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "v",
        "input": "Scrivi una funzione cpp chiamata 'v' con argomenti: ()",
        "output": "v() {\n\t\treturn v;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "funzione",
        "input": "Scrivi una funzione cpp chiamata 'funzione' con argomenti: ()",
        "output": "funzione() {\n\t\treturn *this;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "res",
        "input": "Scrivi una funzione cpp chiamata 'res' con argomenti: ()",
        "output": "res() {\n\t\tModInt res = *this;\n\t\tif (res.v > 0) res.v = MOD - res.v;\n\t\treturn res;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "r",
        "input": "Scrivi una funzione cpp chiamata 'r' con argomenti: (const ModInt &r)",
        "output": "r(const ModInt &r) {\n\t\tif ((v += r.v) >= MOD) v -= MOD;\n\t\treturn *this;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "r",
        "input": "Scrivi una funzione cpp chiamata 'r' con argomenti: (const ModInt &r)",
        "output": "r(const ModInt &r) {\n\t\tif ((v += MOD - r.v) >= MOD) v -= MOD;\n\t\treturn *this;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "r",
        "input": "Scrivi una funzione cpp chiamata 'r' con argomenti: (const ModInt &r)",
        "output": "r(const ModInt &r) {\n\t\tv = (unsigned long long)v * r.v % MOD;\n\t\treturn *this;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "r",
        "input": "Scrivi una funzione cpp chiamata 'r' con argomenti: (const ModInt &r)",
        "output": "r(const ModInt &r) {\n\t\tv = (unsigned long long)v * r.inv() % MOD;\n\t\treturn *this;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "r",
        "input": "Scrivi una funzione cpp chiamata 'r' con argomenti: (const ModInt &r)",
        "output": "r(const ModInt &r) {\n\t\treturn ModInt(*this) += r;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "r",
        "input": "Scrivi una funzione cpp chiamata 'r' con argomenti: (const ModInt &r)",
        "output": "r(const ModInt &r) {\n\t\treturn ModInt(*this) -= r;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "r",
        "input": "Scrivi una funzione cpp chiamata 'r' con argomenti: (const ModInt &r)",
        "output": "r(const ModInt &r) {\n\t\treturn ModInt(*this) *= r;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "r",
        "input": "Scrivi una funzione cpp chiamata 'r' con argomenti: (const ModInt &r)",
        "output": "r(const ModInt &r) {\n\t\treturn ModInt(*this) /= r;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "e",
        "input": "Scrivi una funzione cpp chiamata 'e' con argomenti: (long long e)",
        "output": "e(long long e) {\n\t\tif ((e = e % (MOD - 1) + (MOD - 1)) >= (MOD - 1)) e -= MOD - 1;\n\t\tModInt res = 1, x = *this;\n\t\twhile (e > 0){\n\t\t\tif (e & 1) res *= x;\n\t\t\tx *= x;\n\t\t\te >>= 1;\n\t\t}\n\t\treturn res;\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "pow",
        "input": "Scrivi una funzione cpp chiamata 'pow' con argomenti: ()",
        "output": "pow() {\n\t\treturn pow(MOD - 2);\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "C",
        "input": "Scrivi una funzione cpp chiamata 'C' con argomenti: (int n, int k)",
        "output": "C(int n, int k) {\n\t\tif (k < 0 || n < k) return 0;\n\t\treturn fact[n] * factinv[k] * factinv[n - k];\n\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "prepare",
        "input": "Scrivi una funzione cpp chiamata 'prepare' con argomenti: ()",
        "output": "prepare() {\n\t\t\tinv[1] = 1;\n\t\t\tfor (int i = 2; i <= N; i++){\n\t\t\t\tinv[i] = -(inv[Mod % i] * mint(Mod / i, false));\n\t\t\t}\n\t\t\t\n\t\t\tfact[0] = factinv[0] = 1;\n\t\t\tfor (int i = 1; i <= N; i++){\n\t\t\t\tfact[i] = fact[i - 1] * mint(i);\n\t\t\t\tfactinv[i] = factinv[i - 1] * inv[i];\n\t\t\t}\n\t\t}"
    },
    {
        "task_type": "code_generation",
        "language": "cpp",
        "func_name": "main",
        "input": "Scrivi una funzione cpp chiamata 'main' con argomenti: ()",
        "output": "main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    for(i=1; i<10; i++)\n    {\n        for(j=1; j<10; j++)\n        {\n            cout<<i<<\"x\"<<j<<\"=\"<<i*j<<endl;\n        }\n    }\n\n    return 0;\n}"
    }
]